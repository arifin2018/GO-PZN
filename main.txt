1. Pengenalan Goroutine
- Goroutine akan mengerjakan suatu task secara paralel,di atas thread
- Untuk membuat goroutine di Golang sangatlah sederhana,Kita hanya cukup menambahkan perintah `go` sebelum memanggil function yang akan kita jalankan dalam goroutine
- `go HelloWorld()`
- MINUS => namun ada bahayanya juga menggunakan goroutine,ketika block kode sudah selesai dijalankan semuanya,tapi goroutine belum selesai,maka kita gagal eksekusi Goroutinenya

2. Pengenalan Channel
- Channel adalah tempat komunikasi secara synchronous yang bisa dilakukan oleh goroutine
- karena goroutine async,maka kita bisa menggunakan channel jika program kita yang async dirubah menjadi sync

3. Membuat channel
- `channel := make(chan string)` => yang artinya variable `channel` berisi `chan/channel` kosong yang isinya wajib/harus `string`
- channel bisa digunakan untuk mengirim dan menerima data, untuk mengirim data, kita bisa gunakan kode : `channel <- data`, Sedangkan untuk menerima data, bisa gunakan kode : `data <- channel`
- bisa di liat di Channel_test, function TestChannel

4. Channel Sebagai Parameter
- Dalam kenyataan pembuatan aplikasi, seringnya kita akan mengirim channel ke function lain via parameter,atau function dengan nama

5. Channel In dan Out
-  kita bisa memasukan nilai ke variable 
    - IN memasukan nilai ke variable 
    - OUT mengirim data ke variable yang baru

6. Buffered Channel
- Terkadang ada kasus dimana pengirim lebih cepat dibanding penerima, dalam hal ini jika kita menggunakan channel, maka otomatis pengirim akan ikut lambat juga
- Kita bisa membuat banyak channel,disini membuat 2 channel dalam variable channel 1
- contohnya ada di Channel_test function TestBufferedChannel 

7. Range Channel
- Terkadang ada kasus sebuah channel dikirim data secara terus menerus oleh pengirim
- kita bisa lakukan dengan menggunakan perulangan range ketika menerima data dari channel
- contohnya ada di Channel_test function TestRangeChannel

8. Select Channel
- Kadang ada kasus dimana kita membuat beberapa channel, dan menjalankan beberapa goroutine
- Dengan select channel, kita bisa memilih data tercepat dari beberapa channel, jika data datang secara bersamaan di beberapa channel, maka akan dipilih secara random

9. Race Condition
- Saat kita menggunakan goroutine, dia tidak hanya berjalan secara concurrent, tapi bisa parallel juga, karena bisa ada beberapa thread yang berjalan secara parallel
- Hal ini sangat berbahaya ketika kita melakukan manipulasi data variable yang sama oleh beberapa goroutine secara bersamaan
- contohnya ada di Race_condition_test function TestRaceCondition

10. Mutex
- Untuk mengatasi masalah race condition tersebut, di Go-Lang terdapat sebuah struct bernama sync.Mutex
- Mutex bisa digunakan untuk melakukan locking dan unlocking, dimana ketika kita melakukan locking terhadap mutex, maka tidak ada yang bisa melakukan locking lagi sampai kita melakukan unlock
- contohnya ada di Mutex_test function TestMutex

11. Deadlock
- Hati-hati saat membuat aplikasi yang parallel atau concurrent, masalah yang sering kita hadapi adalah Deadlock
- Deadlock adalah keadaan dimana sebuah proses goroutine saling menunggu lock sehingga tidak ada satupun goroutine yang bisa jalan
- contohnya ada di Mutex_test function TestDeadLock

12. sync.WaitGroup
- WaitGroup adalah fitur yang bisa digunakan untuk menunggu sebuah proses selesai dilakukan
- Hal ini kadang diperlukan, misal kita ingin menjalankan beberapa proses menggunakan goroutine, tapi kita ingin semua proses selesai terlebih dahulu sebelum aplikasi kita selesai
- Kasus seperti ini bisa menggunakan WaitGroup
- contohnya ada di WaitGroup_test function TestWaitGroup

13. sync.Once
- Once adalah fitur di Go-Lang yang bisa kita gunakan untuk memastikan bahsa sebuah function di eksekusi hanya sekali
- Jadi berapa banyak pun goroutine yang mengakses, bisa dipastikan bahwa goroutine yang pertama yang bisa mengeksekusi function nya
- contohnya ada di once_test function TestOnce

14. sync.Pool
- Pool adalah implementasi design pattern bernama object pool pattern. 
- Sederhananya,kita bisa menyimpan datanya sementara lalu di ambil langsung menjadi null
- Implementasi Pool di Go-Lang ini sudah aman dari problem race condition
- contohnya ada di pool_test function TestPool

15. sync.Map
- Go-Lang memiliki sebuah struct beranama sync.Map
- Map ini mirip Go-Lang map, namun yang membedakan, Map ini aman untuk menggunaan concurrent menggunakan goroutine
- contohnya ada di map_test function TestMap

16. sync.Cond
- Cond adalah adalah implementasi locking berbasis kondisi. 
- Cond membutuhkan Locker (bisa menggunakan Mutex atau RWMutex) untuk implementasi locking nya, namun berbeda dengan Locker biasanya, di Cond terdapat function Wait() untuk menunggu apakah perlu menunggu atau tidak
- contohnya ada di cond_test function TestCond

17. Atomic
- Go-Lang memiliki package yang bernama sync/atomic
- Atomic merupakan package yang digunakan untuk menggunakan data primitive secara aman pada proses concurrent
- - contohnya ada di atomic_test function TestAtomic